<?php


function commerce_currencies($enabled = FALSE, $reset = FALSE) {
  global $language;

  $currencies =  &drupal_static(__FUNCTION__);

  if (!isset($currencies) || $reset) {

    if (!$reset && $currencies_cached = cache_get('commerce_currencies:' . $language->$language)) {
      $currencies['all'] = $currencies_cached->data;
    } else {
      $defaults = array(
         'symbol' => '',
        'minor_unit' => '',
        'decimals' => 2,
        'rounding_step' => 0,
        'thousands_separator' => ',',
        'decimal_separator' => '.',
        'symbol_placement' => 'hidden',
        'symbol_spacer' => ' ',
        'code_placement' => 'after',
        'code_spacer' => ' ',
        'format_callback' => '',
        'conversion_callback' => '',
        'conversion_rate' => 1,);
      module_load_include('inc', 'commerce', 'includes/commerce.currencies');
      $currencies['all'] = module_invoke_all('commerce_currency_info');
      drupal_alter('commerce_currency_info', $currency['all'], $language->language);

      foreach ($currencies['all'] as $currency_code => $currency) {
        $currency['all'][$currency_code] = array_merge($defaults, $currency);
      }

      ksort($currency['all']);
      cache_set('commerce_currencies:' . $language->language, $currencies['all']);
    }

    $enabled_currencies = array_diff(array_values(variable_get('commerce_enabled_currencies', array('USD' => 'USD'))), array(0));
    $currencies['enabled'] = array_intersect_key($currencies['all'], drupal_map_assoc($enabled_currencies));
  }

  return $enabled ? $currencies['enabled'] : $currencies['all'];
}

function commerce_default_currency() {
  $currency_code = variable_get('commerce_default_currency', 'USD');
  drupal_alter('commerce_default_currency', $currency_code);
  return $currency_code;
}

function commerce_permission() {
  return array(
      'configure store' => array(
          'title' => t('Configure Store Settings'),
          'description' => t('Allows user to update store currency and contact settings.'),
          'restrict access' => TRUE,
        )
    );
}

function commerce_delete_instances($entity_type, $bundle = NULL) {
  $params = [
    'entity_type' => $entity_type
  ];

  if ( !empty($bundle)) {
    $params['bundle'] = $bundle;
    variable_del('field_bundle_settings_' . $entity_type . '__' . $bundle);
  } else {
    db_delete('variable')
      ->condition('name', db_like('field_bundle_settings_' . $entity_type . '__') . '%', 'LIKE')
      ->execute();
  }

  foreach (field_read_instances($params, array('include_inactive' => TRUE)) as $instance) {
    commerce_delete_instance($instance);
  }
}

function commerce_delete_instance($instance) {
  $field_name = $instance['field_name'];
  $activated = commerce_activate_field($field_name);

  if ($activated) {
    field_cache_clear();
  }

  field_delete_instance($intace, FALSE);

  $field = field_info_field($field_name);

  if( count($field['bundles']) == 0) {
    field_delete_field($field_name);
  } elseif ($activated) {
    $field['active'] =0;
    field_update_field($field);
  }
}


function commerce_entity_access($op, $entity, $account, $entity_type) {
  global $user;
  $account = isset($accout) ? $account : $user;
  $entity_info = entity_get_info($entity_type);
  if ($op == 'view') {
    if (isset($entity)) {
      if (!empty($entity_info['access arguments']['access tag']) &&  module_implements('query_' . $entity_info['access arguments']['access tag'] . '_alter')) {
        $query = db_select($entity_info['base table']);
        $query->addExpression('1');
        return (bool) $query
              ->addTag($entity_info['access arguments']['acess tag'])
              -> addMetaData('account', $account)
              ->addMetaData('entity', $entity)
              ->condition($entity_info['entity keys']['id'], $entity->{$entity_info['entity keys']['id']})
              ->range(0, 1)
              ->execute()
              ->fetchField();
      } else {
        return TRUE;
      }
    } else {
      return user_access('view any ' . $entity_type . ' entity', $account);
    }
  } else {
    $access_results = module_invoke_all('commerce_entity_access', $op, $entity, $account, $entity_type);

        if (in_array(FALSE, $access_results, TRUE)) {
      return FALSE;
    }
    elseif (in_array(TRUE, $access_results, TRUE)) {
      return TRUE;
    }

    if (user_access('administer ' . $entity_type . ' entities', $account)) {
      return TRUE;
    }

    if ($op == 'create') {
        if (isset($entity) && !empty($entity_info['entity keys']['bundle'])) {
        return user_access('create ' . $entity_type . ' entities', $account) || user_access('create ' . $entity_type . ' entities of bundle ' . $entity->{$entity_info['entity keys']['bundle']}, $account);
      }
      else {
        // Otherwise perform an entity type-level access check.
        return user_access('create ' . $entity_type . ' entities', $account);
      }
    } else {
        $bundle_name = '';

      if (isset($entity) && !empty($entity_info['entity keys']['bundle'])) {
        $bundle_name = $entity->{$entity_info['entity keys']['bundle']};
      }

      if (user_access('edit any ' . $entity_type . ' entity', $account) ||
        user_access('edit any ' . $entity_type . ' entity of bundle ' . $bundle_name, $account)) {
        return TRUE;
      }
      // Then check an authenticated user's access to edit his own entities.
      if ($account->uid && !empty($entity_info['access arguments']['user key']) && isset($entity->{$entity_info['access arguments']['user key']}) && $entity->{$entity_info['access arguments']['user key']} == $account->uid) {
        if (user_access('edit own ' . $entity_type . ' entities', $account) ||
          user_access('edit own ' . $entity_type . ' entities of bundle ' . $bundle_name, $account)) {
          return TRUE;
        }
      }
    }
  }

  return FALSE;
}

/**
 * Return permission names for a given entity type.
 */
function commerce_entity_access_permissions($entity_type) {
  $entity_info = entity_get_info($entity_type);
  $labels = $entity_info['permission labels'];

  $permissions = array();

  // General 'administer' permission.
  $permissions['administer ' . $entity_type . ' entities'] = array(
    'title' => t('Administer @entity_type', array('@entity_type' => $labels['plural'])),
    'description' => t('Allows users to perform any action on @entity_type.', array('@entity_type' => $labels['plural'])),
    'restrict access' => TRUE,
  );

  // Generic create and edit permissions.
  $permissions['create ' . $entity_type . ' entities'] = array(
    'title' => t('Create @entity_type of any type', array('@entity_type' => $labels['plural'])),
  );
  if (!empty($entity_info['access arguments']['user key'])) {
    $permissions['edit own ' . $entity_type . ' entities'] = array(
      'title' => t('Edit own @entity_type of any type', array('@entity_type' => $labels['plural'])),
    );
  }
  $permissions['edit any ' . $entity_type . ' entity'] = array(
    'title' => t('Edit any @entity_type of any type', array('@entity_type' => $labels['singular'])),
    'restrict access' => TRUE,
  );
  if (!empty($entity_info['access arguments']['user key'])) {
    $permissions['view own ' . $entity_type . ' entities'] = array(
      'title' => t('View own @entity_type of any type', array('@entity_type' => $labels['plural'])),
    );
  }
  $permissions['view any ' . $entity_type . ' entity'] = array(
    'title' => t('View any @entity_type of any type', array('@entity_type' => $labels['singular'])),
    'restrict access' => TRUE,
  );

  // Per-bundle create and edit permissions.
  if (!empty($entity_info['entity keys']['bundle'])) {
    foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
      $permissions['create ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
        'title' => t('Create %bundle @entity_type', array('@entity_type' => $labels['plural'], '%bundle' => $bundle_info['label'])),
      );
      if (!empty($entity_info['access arguments']['user key'])) {
        $permissions['edit own ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
          'title' => t('Edit own %bundle @entity_type', array('@entity_type' => $labels['plural'], '%bundle' => $bundle_info['label'])),
        );
      }
      $permissions['edit any ' . $entity_type . ' entity of bundle ' . $bundle_name] = array(
        'title' => t('Edit any %bundle @entity_type', array('@entity_type' => $labels['singular'], '%bundle' => $bundle_info['label'])),
        'restrict access' => TRUE,
      );
      if (!empty($entity_info['access arguments']['user key'])) {
        $permissions['view own ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
          'title' => t('View own %bundle @entity_type', array('@entity_type' => $labels['plural'], '%bundle' => $bundle_info['label'])),
        );
      }
      $permissions['view any ' . $entity_type . ' entity of bundle ' . $bundle_name] = array(
        'title' => t('View any %bundle @entity_type', array('@entity_type' => $labels['singular'], '%bundle' => $bundle_info['label'])),
        'restrict access' => TRUE,
      );
    }
  }

  return $permissions;
}


function commerce_delete_fields() {
  // Read the fields for any active or inactive field of the specified type.
  foreach (field_read_fields(array('type' => $type), array('include_inactive' => TRUE)) as $field_name => $field) {
    commerce_delete_field($field_name);
  }
}


/**
 * Enables and deletes the specified field.
 *
 * The normal API function for deleting fields, field_delete_field(), will not
 * work on disabled fields. As a workaround, this function first activates the
 * fields of the specified type and then deletes them.
 *
 * @param $field_name
 *   The name of the field to enable and delete.
 */
function commerce_delete_field($field_name) {
  // In case the field is inactive, first activate it and clear the field cache.
  if (commerce_activate_field($field_name)) {
    field_cache_clear();
  }

  // Delete the field.
  field_delete_field($field_name);
}

function commerce_activate_field($field_name) {
  // Set it to active via a query because field_update_field() does
  // not work on inactive fields.
  $updated = db_update('field_config')
    ->fields(array('active' => 1))
    ->condition('field_name', $field_name, '=')
    ->condition('deleted', 0, '=')
    ->execute();

  return !empty($updated) ? TRUE : FALSE;
}


/**
 * Converts a price amount to a decimal value based on the currency.
 *
 * @param $amount
 *   The price amount to convert to a decimal value.
 * @param $currency_code
 *   The currency code of the price whose decimals value will be used to
 *     divide by the proper divisor when converting the amount.
 *
 * @return
 *   The decimal amount depending on the number of places the currency uses.
 */
function commerce_currency_amount_to_decimal($amount, $currency_code) {
    static $divisors;

  // If the divisor for this currency hasn't been calculated yet...
  if (empty($divisors[$currency_code])) {
    // Load the currency and calculate its divisor as a power of 10.
    $currency = commerce_currency_load($currency_code);
    $divisors[$currency_code] = pow(10, $currency['decimals']);
  }

  return $amount / $divisors[$currency_code];
}


/**
 * Returns a single currency array.
 *
 * @param $currency_code
 *   The code of the currency to return or NULL to return the default currency.
 *
 * @return
 *   The specified currency array or FALSE if it does not exist.
 */
function commerce_currency_load($currency_code = NULL) {
  $currencies = commerce_currencies();
  // Check to see if we should return the default currency.
  if (empty($currency_code)) {
    $currency_code = commerce_default_currency();
  }
    return isset($currencies[$currency_code]) ? $currencies[$currency_code] : FALSE;
}




/**
 * Converts a price amount from a currency to the target currency based on the
 *   current currency conversion rates.
 *
 * The Commerce module establishes a default conversion rate for every currency
 * as 1, so without any additional information there will be a 1:1 conversion
 * from one currency to the next. Other modules can provide UI based or web
 * service based alterations to the conversion rate of the defined currencies as
 * long as every rate is calculated relative to a single base currency. It does
 * not matter which currency is the base currency as long as the same one is
 * used for every rate calculation.
 *
 * To convert an amount from one currency to another, we simply take the amount
 * value and multiply it by the current currency's conversion rate divided by
 * the target currency's conversion rate.
 *
 * @param $amount
 *   The numeric amount value of the price to be rounded.
 * @param $currency_code
 *   The currency code for the current currency of the price.
 * @param $target_currency_code
 *   The currency code for the target currency of the price.
 *
 * @return
 *   The numeric amount value converted to its equivalent in the target currency.
 */
function commerce_currency_convert($amount, $currency_code, $target_currency_code) {
  $currency = commerce_currency_load($currency_code);

   // Invoke the custom conversion callback if specified.
  if (!empty($currency['conversion_callback'])) {
    return $currency['conversion_callback']($amount, $currency_code, $target_currency_code);
  }
  $target_currency = commerce_currency_load($target_currency_code);
  // First multiply the amount to accommodate differences in decimals between
  // the source and target currencies.
  $exponent = $target_currency['decimals'] - $currency['decimals'];
  $amount *= pow(10, $exponent);
  return $amount * ($currency['conversion_rate'] / $target_currency['conversion_rate']);
}




/**
 * Converts a price amount to an integer value for storage in the database.
 *
 * @param $decimal
 *   The decimal amount to convert to a price amount.
 * @param $currency_code
 *   The currency code of the price whose decimals value will be used to
 *     multiply by the proper factor when converting the decimal amount.
 * @param $round
 *   Whether or not the return value should be rounded and cast to an integer;
 *     defaults to TRUE as necessary for standard price amount column storage.
 *
 * @return
 *   The appropriate price amount based on the currency's decimals value.
 */
function commerce_currency_decimal_to_amount($decimal, $currency_code, $round = TRUE) {
  static $factors;

  // If the divisor for this currency hasn't been calculated yet...
  if (empty($factors[$currency_code])) {
    // Load the currency and calculate its factor as a power of 10.
    $currency = commerce_currency_load($currency_code);
    $factors[$currency_code] = pow(10, $currency['decimals']);
  }

  // Ensure the amount has the proper number of decimal places for the currency.
  if ($round) {
    $decimal = commerce_currency_round($decimal, commerce_currency_load($currency_code));
    return (int) round($decimal * $factors[$currency_code]);
  }
  else {
    return $decimal * $factors[$currency_code];
  }
}


/**
 * Rounds a price amount for the specified currency.
 *
 * Rounding of the minor unit with a currency specific step size. For example,
 * Swiss Francs are rounded using a step size of 0.05. This means a price of
 * 10.93 is converted to 10.95.
 *
 * @param $amount
 *   The numeric amount value of the price to be rounded.
 * @param $currency
 *   The currency array containing the rounding information pertinent to this
 *     price. Specifically, this function looks for the 'rounding_step' property
 *     for the step size to round to, supporting '0.05' and '0.02'. If the value
 *     is 0, this function performs normal rounding to the nearest supported
 *     decimal value.
 *
 * @return
 *   The rounded numeric amount value for the price.
 */
function commerce_currency_round($amount, $currency) {
  if (!$currency['rounding_step']) {
    return round($amount, $currency['decimals']);
  }

  $modifier = 1 / $currency['rounding_step'];

  return round($amount * $modifier) / $modifier;
}

/**
 * Wraps commerce_currency_get_code() for use by the Entity module.
 */
function commerce_currency_code_options_list() {
  return commerce_currency_get_code(TRUE);
}



/**
 * Generic implementation of hook_query_alter() for Drupal Commerce entities.
 */
function commerce_entity_access_query_alter($query, $entity_type, $base_table = NULL, $account = NULL) {
  global $user;

    // Read the account from the query if available or default to the current user.
  if (!isset($account) && !$account = $query->getMetaData('account')) {
    $account = $user;
  }


  // Do not apply any conditions for users with administrative view permissions.
  if (user_access('administer ' . $entity_type . ' entities', $account)
    || user_access('view any ' . $entity_type . ' entity', $account)) {
    return;
  }

  // Get the entity type info array for the current access check and prepare a
  // conditions object.
  $entity_info = entity_get_info($entity_type);
  // If a base table wasn't specified, attempt to read it from the query if
  // available, look for a table in the query's tables array that matches the
  // base table of the given entity type, or just default to the first table.
  if (!isset($base_table) && !$base_table = $query->getMetaData('base_table')) {
    // Initialize the base table to the first table in the array. If a table can
    // not be found that matches the entity type's base table, this will result
    // in an invalid query if the first table is not the table we expect,
    // forcing the caller to actually properly pass a base table in that case.
    $tables = $query->getTables();
    reset($tables);
    $base_table = key($tables);
    foreach ($tables as $table_info) {
      if (!($table_info instanceof SelectQueryInterface)) {
        // If this table matches the entity type's base table, use its table
        // alias as the base table for the purposes of bundle and ownership
        // access checks.
        if ($table_info['table'] == $entity_info['base table']) {
          $base_table = $table_info['alias'];
        }
      }
    }
  }

  // Prepare an OR container for conditions. Conditions will be added that seek
  // to grant access, meaning any particular type of permission check may grant
  // access even if none of the others apply. At the end of this function, if no
  // conditions have been added to the array, a condition will be added that
  // always returns FALSE (1 = 0).
  $conditions = db_or();

  // Perform bundle specific permission checks for the specified entity type.
  // In the event that the user has permission to view every bundle of the given
  // entity type, $really_restricted will remain FALSE, indicating that it is
  // safe to exit this function without applying any additional conditions. If
  // the user only had such permission for a subset of the defined bundles,
  // conditions representing those access checks would still be added.
  $really_restricted = FALSE;

  // Loop over every possible bundle for the given entity type.
  foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
    // If the user has access to view entities of the current bundle...
    if (user_access('view any ' . $entity_type . ' entity of bundle ' . $bundle_name, $account)) {
      // Add a condition granting access if the entity specified by the view
      // query is of the same bundle.
      $conditions->condition($base_table . '.' . $entity_info['entity keys']['bundle'], $bundle_name);
    }
    elseif ($account->uid && !empty($entity_info['access arguments']['user key']) && user_access('view own ' . $entity_type . ' entities of bundle ' . $bundle_name, $account)) {
      // Otherwise if an authenticated user has access to view his own entities
      // of the current bundle and the given entity type has a user ownership key...
      $really_restricted = TRUE;

      // Add an AND condition group that grants access if the entity specified
      // by the view query matches the same bundle and belongs to the user.
      $conditions->condition(db_and()
        ->condition($base_table . '.' . $entity_info['entity keys']['bundle'], $bundle_name)
        ->condition($base_table . '.' . $entity_info['access arguments']['user key'], $account->uid)
      );
    }
    else {
      $really_restricted = TRUE;
    }
  }

  // No further conditions need to be added to the query if we determined above
  // that the user has an administrative view permission for any entity of the
  // type and bundles represented by the query.
  if (!$really_restricted) {
    return;
  }

  // If the given entity type has a user ownership key...
  if (!empty($entity_info['access arguments']['user key'])) {
    // Perform 'view own' access control for the entity in the query if the user
    // is authenticated.
    if ($account->uid && user_access('view own ' . $entity_type . ' entities', $account)) {
      $conditions->condition($base_table . '.' . $entity_info['access arguments']['user key'], $account->uid);
    }
  }

  // Prepare an array of condition alter hooks to invoke and an array of context
  // data for the current query.
  $hooks = array(
    'commerce_entity_access_condition_' . $entity_type,
    'commerce_entity_access_condition'
  );

  $context = array(
    'account' => $account,
    'entity' => $query->getMetaData('entity'),
    'entity_type' => $entity_type,
    'base_table' => $base_table
  );

  // Allow other modules to add conditions to the array as necessary.
  drupal_alter($hooks, $conditions, $context);

  // If we have more than one condition based on the entity access permissions
  // and any hook implementations...
  if (count($conditions)) {
    // Add the conditions to the query.
    $query->condition($conditions);
  }
  else {
    // Otherwise, since we don't have any possible conditions to match against,
    // we falsify this query. View checks are access grants, not access denials.
    $query->where('1 = 0');
  }
}



/**
 * Renders a View for display in some other element.
 *
 * @param $view_key
 *   The ID of the View to embed.
 * @param $display_id
 *   The ID of the display of the View that will actually be rendered.
 * @param $arguments
 *   An array of arguments to pass to the View.
 * @param $override_url
 *   A url that overrides the url of the current view.
 *
 * @return
 *   The rendered output of the chosen View display.
 */

function commerce_embed_view($view_id, $display_id, $arguments, $override_url = '') {
    // Load the specified View.
  $view = views_get_view($view_id);
  $view->set_display($display_id);
   // Set the specific arguments passed in.
  $view->set_arguments($arguments);

  // Override the view url, if an override was provided.
  if (!empty($override_url)) {
    $view->override_url = $override_url;
  }

  // Prepare and execute the View query.
  $view->pre_execute();
  $view->execute();

  // Return the rendered View.
  return $view->render();
}